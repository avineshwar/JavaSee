options {
  STATIC = false;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(JavaSeeParser)
package com.github.sider.javasee.parser;

import com.github.sider.javasee.ast.AST;
import com.github.sider.javasee.ast.Location;
import java.util.List;
import java.util.ArrayList;

@SuppressWarnings("unchecked")
public class JavaSeeParser {
      private int mset; // used for semantic lookahead

      private boolean no(int m, int mset) {
        return (m & mset) == 0;
      }

      private boolean la(String s) {
        Token t = getToken(1);
        return t != null && t.image.equals(s);
      }

      /*
       * convenience method to create a Location
       */
      private static Location p(Token t) {
        return new Location(t.beginLine, t.beginColumn);
      }

      /*
       * convenience method to create a Location
       */
      private static Location p(int line, int column) {
        return new Location(line, column);
      }

      /*
       * convenience method to get image of a Token
       */
      private static String c(Token t) {
        return t.image;
      }

      /*
       * converience method to create substring
       */
      private static String sub(String s, int sindex, int eindex) {
        return s.substring(sindex, eindex);
      }

      /*
       * Returns a String which last character of s is omitted.
       */
      private static String chop(String s) {
        return s.substring(0, s.length() - 1);
      }

      /*
       * Returns a String which first and last character of s is omitted.
       */
      private static String chopEdge(String s) {
        return s.substring(1, s.length() - 1);
      }

      private static char unescapeChar(char c) {
        switch(c){
        case 'n' : return '\n';
        case 't' : return '\t';
        case 'b' : return '\b';
        case 'r' : return '\r';
        case 'f' : return '\f';
        case '\\': return '\\';
        case '\'': return '\'';
        case '"' : return '"';
        default  : return c;
        }
      }

      private static String unescape(String s) {
        StringBuffer b = new StringBuffer();
        int len = s.length();
        for(int i = 0; i < len; i++){
          char c = s.charAt(i);
          if(c != '\\'){
            b.append(c);
            continue;
          }
          i++;
          b.append(unescapeChar(s.charAt(i)));
        }
        return new String(b);
      }
}
PARSER_END(JavaSeeParser)

SKIP:
{
  " "
| "\t"
| "\n"
| "\r"
| "\r\n"
}


/*
 * KEYWORDS
 */
TOKEN:
{
  <K_ABSTRACT:     "abstract"     >
| <K_BOOLEAN:      "boolean"      >
| <K_BREAK:        "break"        >
| <K_BYTE:         "byte"         >
| <K_CASE:         "case"         >
| <K_CHAR:         "char"         >
| <K_STRING:       "String"       >
| <K_CLASS:        "class"        >
| <K_CONTINUE:     "continue"     >
| <K_DOUBLE:       "double"       >
| <K_ELSE:         "else"         >
| <K_FINALLY:      "finally"      >
| <K_FINAL:        "final"        >
| <K_FLOAT:        "float"        >
| <K_FOR:          "for"          >
| <K_GOTO:         "goto"         >
| <K_IF:           "if"           >
| <K_IMPORT:       "import"       >
| <K_INT:          "int"          >
| <K_INTERFACE:    "interface"    >
| <K_INSTANCEOF:   "instanceof"   >
| <K_LONG:         "long"         >
| <K_PACKAGE:      "package"      >
| <K_NEW:          "new"          >
| <K_PRIVATE:      "private"      >
| <K_PROTECTED:    "protected"    >
| <K_PUBLIC:       "public"       >
| <K_CATCH:        "catch"        >
| <K_RETURN:       "return"       >
| <K_SWITCH:       "switch"       >
| <K_THIS:         "this"         >
| <K_SHORT:        "short"        >
| <K_STATIC:       "static"       >
| <K_SUPER:        "super"        >
| <K_SYNCHRONIZED: "synchronized" >
| <K_THROW:        "throw"        >
| <K_THROWS:       "throws"       >
| <K_TRY:          "try"          >
| <K_VAR:          "var"          >
| <K_VOID:         "void"         >
| <K_VOLATILE:     "volatile"     >
| <K_WHEN:         "when"         >
| <K_WHILE:        "while"        >
| <K_TRUE:         "true"         >
| <K_FALSE:        "false"        >
| <K_NULL:         "null"         >
}


/*
 * OTHERS
 */
TOKEN : {
  <R3S:            ">>>"          >
| <ARROW:          "->"           >
| <NOT:            "!"            >
| <AND:            "&&"           >
| <OR:             "||"           >
| <EOR:            "^"            >
| <BN:             "~"            >
| <L2S:            "<<"           >
| <R2S:            ">>"           >
| <SHARPLT:        "#<"           >
| <LTSHARP:        ">#"           >
| <SHARPBRACKET:   "#["           >
| <EQ:             "=="           >
| <NOTEQ:          "!="           >
| <ADDEQ:          "+="           >
| <SUBEQ:          "-="           >
| <MULEQ:          "*="           >
| <DIVEQ:          "/="           >
| <REMEQ:          "%="           >
| <ANDEQ:          "&="           >
| <OREQ:           "|="           >
| <XOREQ:          "^="           >
| <PLUSPLUS:       "++"           >
| <MINUSMINUS:     "--"           >
| <ATMARK:         "@"            >
| <ATMARKEUQSTION: "@?"           >
| <AMP:            "&"            >
| <COLON:          ":"            >
| <SEMI:           ";"            >
| <COLON2:         "::"           >
| <SHARP:          "#"            >
| <DOT:            "."            >
| <LBRACE:         "{"            >
| <RBRACE:         "}"            >
| <BACK_QUOTE:     "`"            >
| <LPAREN:         "("            >
| <RPAREN:         ")"            >
| <COMMA:          ","            >
| <LBRACKET:       "["            >
| <RBRACKET:       "]"            >
| <QUESTION:       "?"            >
| <VARARGS:        "..."          >
| <ASSIGN:         "="            >
| <BAR:            "|"            >
| <PLUS:           "+"            >
| <MINUS:          "-"            >
| <STAR:           "*"            >
| <SLASH:          "/"            >
| <PERC:           "%"            >
| <DOLLAR:         "$"            >
| <LT:             "<"            >
| <GT:             ">"            >
| <UNDERSCORE:     "_"            >
}

/*
 * LITERALS
 */
TOKEN:
{
  <INTEGER:
    <DECIMAL_LITERAL> (["L"])?
  | <HEX_LITERAL> (["L"])?
  | <OCTAL_LITERAL> (["L"])?
  >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| <#OCTAL_LITERAL: "0" (["0"-"7"])* >
| <DOUBLE:
    (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["F", "D"])?
  | "." (["0"-"9"])+ (<EXPONENT>)? (["F","D"])?
  | (["0"-"9"])+ <EXPONENT> (["F","D"])?
  | (["0"-"9"])+ (<EXPONENT>)? ["F","D"]
  >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER:
    "'"
    ( (~["'","\\","\n","\r"])
    | ("\\"
        ( ["n","t","b","r","f","\\","'","\""]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        )
      )
    )
    "'"
  >
| <STRING:
    "\""
    ( (~["\"","\\","\n","\r"])
    | ("\\"
        ( ["n","t","b","r","f","\\","'","\""]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        )
      )
    )*
    "\""
  >
| <ID:       ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >
}

/*
 * ERROR TOKEN
 */
TOKEN:{
  <ERROR: ~[]>
}

AST.Expression Target() :{AST.Expression e;} {
    e=KindedExpression() {return e;}
}

AST.Expression KindedExpression() :{
    AST.Expression e;
} {
    e=Expression() {return e;}
}

AST.Expression WholeExpression(): {AST.Expression e;} {
  e=Expression() <EOF> {return e;}
}

AST.Expression Expression(): {Token t; AST.Expression a, b;}{
  a=Conditional() [t=AssignmentOperator() b=Expression()
    {
        switch(t.image) {
            case "=":
                a = new AST.SimpleAssignment(p(t), a, b);
                break;
            case "+=":
                a = new AST.AdditionAssignment(p(t), a, b);
                break;
            case "-=":
                a = new AST.SubtractionAssignment(p(t), a, b);
                break;
            case "*=":
                a = new AST.MultiplicationAssignment(p(t), a, b);
                break;
            case "/=":
                a = new AST.DivisionAssignment(p(t), a, b);
                break;
            case "%=":
                a = new AST.RemainderAssignment(p(t), a, b);
                break;
            case "&=":
                a = new AST.BitwiseAndAssignment(p(t), a, b);
                break;
            case "|=":
                a = new AST.BitwiseOrAssignment(p(t), a, b);
                break;
            case "^=":
                a = new AST.XorAssignment(p(t), a, b);
                break;
            default:
                throw new Error("cannot reach here");
        }
    }
  ] {
      return a;
  }
}

Token AssignmentOperator(): {Token t;} {
(
  t="="
| t="+="
| t="-="
| t="*="
| t="/="
| t="%="
| t="&="
| t="|="
| t="^="
) {return t;}
}

AST.Expression Conditional(): {AST.Expression c, l, r; }
{
  c=LogicalOr() ["?" l=Expression() ":" r=Conditional() {c = new AST.ConditionalExpression(c.getLocation(), c, l, r);}] {return c;}
}

AST.Expression LogicalOr() :{Token t; AST.Expression a, b;}{
  a=LogicalAnd() (t="||" b=LogicalAnd() {a = new AST.ConditionalOrExpression(p(t), a, b);})* {return a;}
}

AST.Expression LogicalAnd() :{Token t; AST.Expression a, b; }{
  a=BitwiseOr() (t="&&" b=BitwiseOr() {a = new AST.ConditionalAndExpression(p(t), a, b);})* {return a;}
}

AST.Expression BitwiseOr() :{Token t; AST.Expression a, b; }{
  a=Xor() (t="|" b=Xor() {a = new AST.BitwiseOrExpression(p(t), a, b);})* {return a;}
}

AST.Expression Xor() :{Token t; AST.Expression a, b;}{
  a =BitwiseAnd() (t="^" b=BitwiseAnd() {a = new AST.XorExpression(p(t), a, b);})* {return a;}
}

AST.Expression BitwiseAnd() :{Token t; AST.Expression a, b; }{
  a=Equal() (t = "&" b=Equal() {a = new AST.BitwiseAndExpression(p(t), a, b);})* {return a;}
}

AST.Expression Equal() :{ Token t; AST.Expression a, b; }{
  a=Instanceof()
  ( ( t="=="  b=Comparative() {a= new AST.Equal(p(t), a, b);}
    | t="!="  b=Comparative() {a= new AST.NotEqual(p(t), a, b);}
    )
  )* {return a;}
}

AST.Expression Instanceof(): {Token n, t; AST.Expression a;} {
  a=Comparative() [ t="instanceof" n=<ID> {a = new AST.InstanceofExpression(p(n), a, c(n));} ] { return a;}
}

AST.Expression Comparative() : { Token t; AST.Expression a, b; Token n; }{
  a=BitShift()
  ( ( t="<=" b=BitShift() {a = new AST.LessOrEqual(p(t), a, b);}
    | t=">=" b=BitShift() {a = new AST.GreaterOrEqual(p(t), a, b);}
    | t="<"  b=BitShift() {a = new AST.LessThan(p(t), a, b);}
    | t=">"  b=BitShift() {a = new AST.GreaterThan(p(t), a, b);}
    )
  )* {return a;}
}

AST.Expression BitShift() :{Token t; AST.Expression e1, e2;}{
  e1=Additive()
( t="<<" e2=Additive()    {e1 = new AST.LeftShiftExpression(p(t), e1, e2);}
| t=">>" e2=Additive()    {e1 = new AST.RightShiftExpression(p(t), e1, e2);}
| t=">>>"e2=Additive()    {e1 = new AST.UnsignedRightShiftExpression(p(t), e1, e2);}
)* { return e1; }
}

AST.Expression Additive() :{Token t; AST.Expression e1, e2;}{
  e1=Multitive()
( t="+" e2=Multitive() {e1 = new AST.Addition(p(t), e1, e2);}
| t="-" e2=Multitive() {e1 = new AST.Subtraction(p(t), e1, e2);}
)* {return e1;}
}

AST.Expression Multitive() :{Token t; AST.Expression e1, e2;}{
  e1=UnaryPrefix1()
( t="*" e2=UnaryPrefix1()  {e1 = new AST.Multiplication(p(t), e1, e2);}
| t="/" e2=UnaryPrefix1()  {e1 = new AST.Division(p(t), e1, e2);}
| t="%" e2=UnaryPrefix1()  {e1 = new AST.Remainder(p(t), e1, e2);}
)* {return e1;}
}


AST.Expression UnaryPrefix1() :{Token t; AST.Expression e;}{
( t="++" e=UnaryPrefix1() {e = new AST.PrefixIncrementExpression(p(t), e);}
| t="--" e=UnaryPrefix1() {e = new AST.PrefixDecrementExpression(p(t), e);}
| t="+"  e=UnaryPrefix1() {e = new AST.UnaryPlusExpression(p(t), e);}
| t="-"  e=UnaryPrefix1() {e = new AST.UnaryMinusExpression(p(t), e);}
| e=UnaryPrefix2()
) {return e;}
}

AST.Expression UnaryPrefix2() :{Token t; AST.Expression e;}{
( t="!" e=UnaryPrefix1() {e = new AST.LogicalComplementExpression(p(t), e);}
| t="~" e=UnaryPrefix1() {e = new AST.BitwiseComplementExpression(p(t), e);}
| e=Postfix()
) {return e;}
}

AST.Expression Postfix(): {Token t; AST.Expression e;} {
  e=PrimarySuffix() [
    LOOKAHEAD(2)
    ( t="++"                                                                {e = new AST.PostIncrement(p(t), e);}
    | t="--"                                                                {e = new AST.PostDecrement(p(t), e);}
    )
  ]
  {return e;}
}

AST.Expression PrimarySuffix() :{
  Token t, n; AST.Expression e, a = null; List<AST.Expression> params = null;
}{
  e=Primary()
( t="[" a=Expression() "]"                                                {e = new AST.ArrayAccessExpression(p(t), e, a);}
| e=Selection(e)
)* {return e;}
}

AST.Expression Selection(AST.Expression receiver) : {
  Token t, n; List<AST.Expression> params = null;
} {
  t="." n=<ID> ["(" params=Parameters() ")"]                              {
    if(params != null) {
        return new AST.MethodCall(p(t), receiver, c(n), params);
    } else {
        return new AST.FieldSelection(p(t), receiver, c(n));
    }
  }
}

AST.Expression Primary() :{
    Token n;
    AST.Expression e;
    List<AST.Expression> params = null;
}{

    e=BooleanPattern()                                                      {return e;}
|   e=StringPattern()                                                       {return e;}
|   e=IntPattern()                                                          {return e;}
|   e=DoublePattern()                                                       {return e;}
|   e=PlaceholderPattern()                                                  {return e;}
|   e=NullPattern()                                                         {return e;}
|   e=LambdaPattern()                                                       {return e;}
|   e=Wildcard()                                                            {return e;}
|   e=ThisPattern()                                                         {return e;}
|   e=ClassLiteral()                                                        {return e;}
|   e=RepeatedParameter()                                                   {return e;}
|  n="@?"                                                                   {return new AST.AnyID(p(n));}
|  n=<ID> ["(" params=Parameters() ")"]                                     {return params != null ? new AST.FunctionCall(p(n), c(n), params) : new AST.ID(p(n), n.image); }
| "(" e=Expression() ")"                                                    {return e;}
|  e=NewExpression()                                                        {return e;}
}


AST.Expression RepeatedParameter(): {Token t;} {
    t="..."                                                                 {return new AST.RepeatedParameter(p(t));}
}

AST.Expression NewExpression(): {Token t; AST.ID id; AST.Expression e; List<AST.Expression> es = null;} {
  t="new" id=Identifier() (
    "(" es=Parameters() ")" {return new AST.InstanceCreationExpression(p(t), id.name, es);}
  | {es = new ArrayList<AST.Expression>();}
    ("#[" e=Expression() "]" {es.add(e);})+ {return new AST.ArrayCreationExpression(p(t), id.name, es);}
  )
}

List<AST.Expression> Parameters() :{AST.Expression param; List<AST.Expression> params = new ArrayList<AST.Expression>();}{
  [param=Expression() {params.add(param);} ("," param=Expression() {params.add(param);})*] {
    return params;
  }
}

AST.ID Identifier() :{Token t;} {
    t=<ID> {return new AST.ID(p(t), t.image);}
}

AST.Expression Wildcard() :{Token t;}{
    t="_"                         {return new AST.Wildcard(p(t));}
}

AST.Expression ThisPattern() :{Token t;}{
    t="this"                      {return new AST.ThisLiteral(p(t));}
}

AST.Expression ClassLiteral() :{Token t, n; List<String> fragments = new ArrayList<String>(); }{
    "class" t="[" n=<ID> {fragments.add(n.image);} (LOOKAHEAD(2) "." n=<ID> {fragments.add(n.image);})* "]" {
        return fragments.size() == 1 ?
            new AST.ClassLiteral(p(t), List.of(), fragments.get(0)) :
            new AST.ClassLiteral(p(t), fragments.subList(0, fragments.size() - 1), fragments.get(fragments.size() - 1));
    }
}

AST.Expression NullPattern() :{Token t;}{
    t="null"                      {return new AST.NullLiteral(p(t));}
}

AST.Expression PlaceholderPattern(): {Token t; AST.Expression e;} {
  t="@" (
    "int"                    {return new AST.IntWildcard(p(t));}
  | "double"                 {return new AST.DoubleWildcard(p(t));}
  | "boolean"                {return new AST.BooleanWildcard(p(t));}
  | "String"                 {return new AST.StringWildcard(p(t));}
  )
}

AST.Expression DoublePattern() :{Token t;}{
    t=<DOUBLE>                    {return new AST.DoubleLiteral(p(t), Double.parseDouble(t.image));}
}

AST.Expression IntPattern() :{Token t;}{
    t=<INTEGER>                   {return new AST.IntLiteral(p(t), Integer.parseInt(t.image));}
}

AST.Expression LambdaPattern(): {Token t;}{
    t="->"                     {return new AST.LambdaPattern(p(t));}
}


AST.Expression BooleanPattern() :{Token t;}{
    t=<K_TRUE>                      {return new AST.BooleanLiteral(p(t), true);}
|   t="false"                     {return new AST.BooleanLiteral(p(t), false);}
}

AST.Expression StringPattern() :{Token t;}{
    t=<STRING>                    {return new AST.StringLiteral(p(t), unescape(chopEdge(t.image)));}
}

/*
AST.CharacterLiteral char_literal() :{Token t;}{
  t=<CHARACTER> {return new AST.CharacterLiteral(p(t), unescape(chopEdge(t.image)).charAt(0));}
}
*/
